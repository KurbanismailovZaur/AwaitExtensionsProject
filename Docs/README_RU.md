# AwaitExtensions
AwaitExtensions - это библиотека для игрового движка Unity, которая позволит вам применять паттер async/await для множества Unity-классов.

# Что такое `async`/`await`?
`async`/`await` — это синтаксический сахар, упрощающий работу с асинхронным кодом. Когда вам нужно дождаться завершения выполнения объекта `Task` (или объекта, реализующего `GetAwaiter`), вы просто пишете ключевое слово `await` перед ним, и весь код следующий после этого этой инструкции запускается после завершения задачи. Метод, содержащий ключевое слово `await`, необходимо пометить как `async`.

Механизм `async`/`await` был интегрирован в C# 5.0 и .NET 4.5.
Для получения подробной информации о том, как использовать `async`/`await`, посетите сайт Microsoft.

Unity и `async`/`await`
Unity официально поддерживает C# 5.0 и .NET 4.5, начиная с версии 2018 года. Это означает, что вы можете без проблем использовать эти инструкции. Пример ниже демонстрирует, как вы можете подождать 1 секунду реального времени в методе Awake с помощью `async`/`await`:

```c#
private async void Awake()
{
  await Task.Delay(1000);
  Log("Awaited");
}
```

Метод `Log("Awaited")` будет вызван из основного потока после ожидания 1000 миллисекунд.

Вы можете использовать почти все возможности C# в Unity, однако по умолчанию Unity не поддерживает ожидание собственных типов (WaitForSeconds и прочие), например этот код не будет работать:

```c#
private async void Awake()
{
  await new WaitForSeconds(1f); // оошибка, await не понимает как ожидать объект WaitForSeconds.
  Log("Awaited");
}
```

Это потому, что `await` не знает, как ожидать объект `WaitForSeconds`. Если мы «объясним» ему как ожидать — то он сможет. Чтобы «объяснить» `await`'у, как объект WaitForSeconds должен быть обработан, нам нужно создать метод расширения `GetAwaiter` для класса `WaitForSeconds`, который возвращает некоторый объект, который знает, как ожидать `WaitForSeconds` и который используется ключевым словом `await`.

Все зависящие от времени операции (WaitForFixedUpdate, WaitUntil, ожидание корутин, ожидание WWW-запроса и другие) могут быть легко расширены описанным выше методом, а затем использованы с ключевым словом `await`.

# Что именно делает Await Extensions?
Он расширяет многие классы Unity для работы с ключевым словом `await`. Посмотрите на пример ниже, он показывает все варианты использования инструкции `await` с ассетом Await Extensions:

```c#
private async void Awake()
{
  // Ожидаем задачу.
  await Task.Delay(1000);
  
  // Ожидаем стандартные Unity Wait-объекты.
  await new WaitForEndOfFrame();
  await new WaitForFixedUpdate();
  await new WaitForSeconds(1f);
  await new WaitForSecondsRealtime(1f);
  await new WaitUntil(() => true);
  await new WaitWhile(() => false);
  
  // Ожидаем завершения IEnumerator-объекта. Под капотом используется движок корутин Unity, поэтому это не вызывает каких-либо проблем.
  await EnumerateSomething();
  
  // waiting for something to load from the network.
  await UnityWebRequest.Get("google.com").SendWebRequest();
  
  // Ожидаем загрузку ассета.
  var prefab = (GameObject)(await www.assetBundle.LoadAssetAsync("MyAsset")).asset;
  
  // Ожидаем загрузку сцены.
  await SceneManager.LoadSceneAsync(0);
  
  Debug.Log("Конец метода Awake");
}

private IEnumerator EnumerateSomething()
{
  yield return new WaitForSeconds(1f);
  Debug.Log("Эта строка будет отображена в консоли после того как ожидание предыдущей строки будет завершено.");
}
```

За кулисами Await Extension для ожидания использует движок корутин Unity. Это означает, что вы можете использовать все операции, зависящие от времени, и они будут правильно обработаны.

# Потоки
Что если вы хотите чтобы некоторая часть метода выполнялась в фоновом потоке, а остальная часть - в основном? Вы можете сделать это с помощью двух специальных классов: `WaitForBackgroundThread` и `WaitForUpdate`. Вы просто должны подождать один из этих объектов, чтобы код который расположен далее начал выполняться в соответствующем потоке. Посмотрите на код ниже:

```c#
private async void Awake()
{
  Debug.Log("Привет из основного потока!");
  
  // Код расположенный после этой строки будет выполняться в фоновом потоке.
  // Не используйте Unity API (GameObject, Components и прочие) в фоновом потоке, это запрешщено.
  await new WaitForBackgroundThread();
  
  // Эта инструкция будет выполнена в фоновом потоке.
  int result = HeavyCalculations();
  
  // Код расположенный после этой строки будет выполняться в основном потоке.
  await new WaitForUpdate();
  
  // Эта инструкция выполняется в основном потоке.
  Debug.Log(result);
}

private int HeavyCalculations()
{
  int result = 0;
  for (int i = 0; i < 1024; i++)
    result += i;
    
  return result;
}
```

Код после ожидания `WaitForBackgroundThread` выполняется в фоновом потоке.
Код после ожидания `WaitForUpdate` запускается в основном потоке после цикла Update (вызывается самим Unity). Ожидание `WaitForUpdate` в основном потоке просто пропускает один кадр.

# Асинхронные методы и исключения
В асинхронном методе исключения перехватываются задачей, в которой они произошли. Это означает, что если вы вызываете асинхронный метод из синхронного - вам нужно вручную дождаться его (а в этом случае основной поток будет заблокирован на время ожидания), иначе исключения останутся необработанными. Посмотрите на код ниже:

```c#
private void Awake()
{
  // В этом случае исключение вызыванное внутри задачи будет перехвачено самой задачей (которую создает и возвращает метод `CreateTask`).
  CreateTask();
  
  // В этом случае мы явно ждем завершения задачи, которую вернул метод `CreateTask`, что означает, что исключение будет проброшено в основной поток и произойдет там,
  // однако основной поток зависнет на время ожидания задачи.
  CreateTask.Wait();
}

private Task CreateTask() => Task.Run(() => throw new Exception());
```

Здесь в первом случае мы создаем задачу и забываем о ней (исключения не будут генерироваться в основном потоке), во втором случае мы ждем ее вручную (основной поток зависнет, но исключения будут генерироваться в основном потоке).

Однако есть еще один способ отлова исключений - использовать `async void` метод, который вызывается из синхронного метода и вызывает асинхронный метод с ожиданием. В этом случае исключение будет повторно сгенерировано в `UnitySynchronizationContext` в его методе `Update`, который вызывается из основного потока Unity, это означает, что Unity перехватит это исключение, или вы можете перехватить его вручную с помощью инструкции `try/catch`. Посмотрите на код ниже:

```c#
// CreateTaskAndCatchErrors вызывается из основного потока.
private async void Awake() => CreateTaskAndCatchErrors();

// Запускаем задачу с помощью CreateTask и ожидаем ее.
private async void CreateTaskAndCatchErrors() => await CreateTask();

// Генерируем исключение в задаче.
private Task CreateTask() => Task.Run(() => throw new Exception()); 
```

Теперь исключения будут перехватываться Unity. Но нам всегда нужно создавать дополнительный `async void` метод, что не очень хорошо. К счастью, вам не нужно создавать `async void`, просто используйте метод расширения `CatchErrors` для объекта типа `Task`, который повторно выдает ошибку в основном потоке, если она возникает.

```c#
// CreateTaskAndCatchErrors вызывается из основного потока. Исключения будут перехвачены методом расширения CatchErrors.
private async void Awake() => CreateTaskAndCatchErrors().CatchErrors();

// Генерируем исключение в задаче.
private Task CreateTask() => Task.Run(() => throw new Exception()); 
```

Запомните: никогда не оставляйте исключения необработанными, если не хотите большой головной боли в будущем.

# Преобразование между `IEnumerator`, `Task` и `Coroutine`
Вы можете преобразовать любой объект `Task` в объект `IEnumerator`. Это полезно из соображений обратной совместимости. Просто вызовите метод расширения `AsEnumerator` для задачи. Объект `IEnumerator` будет перечисляться, пока задача не завершена. Пример:

```c#
private IEnumerator Start()
{
  // Конвертируем Task в IEnumerator.
  var enumerator = Task.Delay(1000).AsEnumerator();
  
  // Ожидаем задачу с помощью IEnumerator-объекта
  while (enumerator.MoveNext())
    yield return null;
    
  Debug.Log("Ожидание задачи завершено!");
}
```

Пример выше можно сделать более компактным:

```c#
private IEnumerator Start()
{
  // Конвертируем Task в IEnumerator и ждем его завершения с помощью движка корутин Unity.
  yield return StartCoroutine(Task.Delay(1000).AsEnumerator());
  
  Debug.Log("Ожидание задачи завершено!");
}
```

Этот пример также можно сделать еще короче, если использовать метод `AsCoroutine`, который конвертирует задачу в корутину:

```c#
private IEnumerator Start()
{
  // Конвертируем Task в IEnumerator и ждем его завершения с помощью движка корутин Unity.
  yield return Task.Delay(1000).AsCoroutine();
  
  Debug.Log("Ожидание задачи завершено!");
}
```

# Заключение
Теперь вы можете использовать асинхронные методы бок о бок с корутинами и `IEnumerator`-объектами, а выполнять код в фоновом потоке стало заметно проще.

Вы можете ожидать:
* Любой объект `YieldInstuction` (`WaitForEndOfFrame`, `WaitForFixedUpdate`, `WaitForSeconds`, `Coroutine`, `AsyncOperation` и другие производные классы);
* Любой объект `CustomYieldInstruction` (`WaitForSecondsRealtime`, `WaitUntil`, `WaitWhile` и другие);
* `WWW`-объект с результатом;
* `AssetBundleRequest` с результатом;
* `IEnumerator`;
* `WaitForUpdate` - для выпорлнения кода в основном потоке;
* `WaitForBackgroundThread` - для выполнения кода во вторичном потоке.

После ожидания любого из перечисленных выше типов объектов (кроме `WaitForBackgroundThread`) код расположенный далее всегда выполняется в основном потоке.

Также вы можете преобразовать задачу в `IEnumerator` или `Coroutine` для обратной совместимости.
